// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: all.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fuzzyFindPlaceBuildingClassroom = `-- name: FuzzyFindPlaceBuildingClassroom :many
WITH Combined AS
         (
             SELECT id, name, geom, category_id, NULL::TEXT[] AS image_urls
             FROM place
             WHERE name ILIKE '%' || $1::text || '%'

UNION

SELECT id, name, ST_Centroid(geom) as geom, category_id, image_urls
FROM building
WHERE name ILIKE '%' || $1::text || '%'

UNION

SELECT classroom.id,
       COALESCE(classroom.room_code, classroom.name) as name,
       ST_Centroid(building.geom) as geom,
       classroom.category_id,
       NULL::TEXT[] AS image_urls
FROM classroom
         JOIN building ON classroom.building_id = building.id
WHERE classroom.room_code ILIKE '%' || $1::text || '%'
       OR classroom.name ILIKE '%' || $1::text || '%'
)
SELECT id,
       name,
       category_id,
       ST_AsText(ST_Transform(geom, 4326)) as geom,
       image_urls
FROM Combined
`

type FuzzyFindPlaceBuildingClassroomRow struct {
	ID         int64       `json:"id"`
	Name       string      `json:"name"`
	CategoryID pgtype.Int4 `json:"category_id"`
	Geom       interface{} `json:"geom"`
	ImageUrls  []string    `json:"image_urls"`
}

func (q *Queries) FuzzyFindPlaceBuildingClassroom(ctx context.Context, text string) ([]FuzzyFindPlaceBuildingClassroomRow, error) {
	rows, err := q.db.Query(ctx, fuzzyFindPlaceBuildingClassroom, text)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FuzzyFindPlaceBuildingClassroomRow{}
	for rows.Next() {
		var i FuzzyFindPlaceBuildingClassroomRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.Geom,
			&i.ImageUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingOrPlace = `-- name: GetBuildingOrPlace :one
WITH Combined AS
         (
             SELECT name, ST_AsText(geom) as geom
             FROM place
             WHERE place.name = $1::text

UNION

SELECT name, ST_AsText(ST_Centroid(geom)) as geom
FROM building
WHERE building.name = $1::text

UNION

SELECT CASE
           WHEN classroom.room_code IS NOT NULL THEN classroom.room_code
           ELSE classroom.name
           END || ' (' || building.name || ')' as name,
       ST_AsText(ST_Centroid(building.geom)) as geom
FROM classroom
         JOIN building ON classroom.building_id = building.id
WHERE classroom.room_code = $1::text OR classroom.name = $1::text
)
SELECT name, geom
FROM Combined
         LIMIT 1
`

type GetBuildingOrPlaceRow struct {
	Name string      `json:"name"`
	Geom interface{} `json:"geom"`
}

func (q *Queries) GetBuildingOrPlace(ctx context.Context, name string) (GetBuildingOrPlaceRow, error) {
	row := q.db.QueryRow(ctx, getBuildingOrPlace, name)
	var i GetBuildingOrPlaceRow
	err := row.Scan(&i.Name, &i.Geom)
	return i, err
}

const getClosestPointToQueryLocationByLatLngGeom = `-- name: GetClosestPointToQueryLocationByLatLngGeom :one
SELECT id,
       name,
       ST_ASTEXT(geom) AS closest_geom
FROM node
ORDER BY geom <-> st_transform(ST_GEOMFROMTEXT($1, 4326), 3857) LIMIT 1
`

type GetClosestPointToQueryLocationByLatLngGeomRow struct {
	ID          int64       `json:"id"`
	Name        string      `json:"name"`
	ClosestGeom interface{} `json:"closest_geom"`
}

func (q *Queries) GetClosestPointToQueryLocationByLatLngGeom(ctx context.Context, stGeomfromtext interface{}) (GetClosestPointToQueryLocationByLatLngGeomRow, error) {
	row := q.db.QueryRow(ctx, getClosestPointToQueryLocationByLatLngGeom, stGeomfromtext)
	var i GetClosestPointToQueryLocationByLatLngGeomRow
	err := row.Scan(&i.ID, &i.Name, &i.ClosestGeom)
	return i, err
}
